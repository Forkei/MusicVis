#version 430 core

// One workgroup per loop, 240 threads = 24 control points × 10 subdivisions
layout(local_size_x = 240) in;

// --- Input: Loop data SSBO ---
// Per loop: 24 CPs × 5 floats (base_theta, base_phi, noise_phase0, noise_phase1, noise_phase2)
//         + 9 floats (rotation matrix 3x3)
//         + 4 floats (base_thickness, base_brightness, hue_offset, band_index)
//         = 133 floats per loop
layout(std430, binding = 0) buffer LoopData {
    float loop_data[];
};

// --- Output: Segment data SSBO (also used as instance VBO) ---
// Per segment: 8 floats (x0, y0, x1, y1, thickness, brightness, hue, depth)
// Total: loop_count × 240 × 8 floats
layout(std430, binding = 1) buffer SegmentData {
    float segment_data[];
};

// --- Uniforms ---
uniform float u_time;
uniform float u_radius;
uniform vec2 u_center;       // screen center (cx, cy)
uniform float u_rotation_angle;
uniform float u_perspective_d;
uniform float u_noise_intensity;
uniform float u_noise_speed;
uniform float u_bass;
uniform float u_mid;
uniform float u_treble;
uniform float u_kick;
uniform float u_snare;
uniform float u_rms;
uniform float u_volume_scatter;
uniform float u_angular_boost;
uniform int u_loop_count;
uniform int u_active_loops;   // for dynamic dimming

// --- Shared memory for control points ---
shared vec3 control_points[24];

// Multi-sine noise function matching the CPU version
float multi_sine_noise(float phase, float t, float speed) {
    float ts = t * speed;
    return sin(phase * 0.5 + ts * 0.7) * 0.3
         + sin(phase + ts) * 0.4
         + sin(phase * 1.7 + ts * 2.3) * 0.2
         + sin(phase * 0.3 + ts * 4.1) * 0.1;
}

// Catmull-Rom interpolation for a single dimension
float catmull_rom_1d(float p0, float p1, float p2, float p3, float t) {
    float t2 = t * t;
    float t3 = t2 * t;
    float a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;
    float b = p0 - 2.5 * p1 + 2.0 * p2 - 0.5 * p3;
    float c = -0.5 * p0 + 0.5 * p2;
    float d = p1;
    return a * t3 + b * t2 + c * t + d;
}

vec3 catmull_rom_3d(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {
    return vec3(
        catmull_rom_1d(p0.x, p1.x, p2.x, p3.x, t),
        catmull_rom_1d(p0.y, p1.y, p2.y, p3.y, t),
        catmull_rom_1d(p0.z, p1.z, p2.z, p3.z, t)
    );
}

void main() {
    uint loop_idx = gl_WorkGroupID.x;
    uint local_id = gl_LocalInvocationID.x;

    if (loop_idx >= u_loop_count) return;

    // Read loop metadata
    uint loop_base = loop_idx * 133;

    // Rotation matrix (9 floats at offset 24*5=120)
    uint rm_base = loop_base + 120;
    mat3 rot_matrix = mat3(
        loop_data[rm_base + 0], loop_data[rm_base + 1], loop_data[rm_base + 2],
        loop_data[rm_base + 3], loop_data[rm_base + 4], loop_data[rm_base + 5],
        loop_data[rm_base + 6], loop_data[rm_base + 7], loop_data[rm_base + 8]
    );

    // Visual properties (4 floats at offset 129)
    uint vp_base = loop_base + 129;
    float base_thickness = loop_data[vp_base + 0];
    float base_brightness = loop_data[vp_base + 1];
    float hue_offset = loop_data[vp_base + 2];
    float band_index = loop_data[vp_base + 3];

    // Band-specific energy response (wider range for more dynamic visuals)
    float band_energy;
    if (band_index < 0.5) {
        band_energy = u_bass * 2.0;
    } else if (band_index > 1.5) {
        band_energy = u_treble * 2.5;
    } else {
        band_energy = u_mid * 1.5;
    }

    // Global rotation
    float cos_rot = cos(u_rotation_angle);
    float sin_rot = sin(u_rotation_angle);

    // --- Phase 1: Threads 0-23 animate control points ---
    if (local_id < 24) {
        uint cp_base = loop_base + local_id * 5;
        float base_theta = loop_data[cp_base + 0];
        float base_phi   = loop_data[cp_base + 1];
        float np0        = loop_data[cp_base + 2];
        float np1        = loop_data[cp_base + 3];
        float np2        = loop_data[cp_base + 4];

        // Compute noise
        float noise_theta = multi_sine_noise(np0, u_time, u_noise_speed) * u_noise_intensity * u_angular_boost;
        float noise_phi   = multi_sine_noise(np1, u_time, u_noise_speed) * u_noise_intensity * u_angular_boost;
        float noise_r     = multi_sine_noise(np2, u_time, u_noise_speed);

        // Animated spherical coords
        float theta = base_theta + noise_theta * 3.14159265;
        float phi   = base_phi + noise_phi * 6.28318530;

        // Radial scatter
        float r_base = 1.0 - u_volume_scatter * 0.7;
        float r_spread = u_noise_intensity * 0.5 + u_volume_scatter * 0.5;
        float r_factor = clamp(r_base + noise_r * r_spread, 0.1, 1.3);

        // Spherical to Cartesian
        float st = sin(theta);
        float ct = cos(theta);
        float sp = sin(phi);
        float cp = cos(phi);

        vec3 local_pos = vec3(st * cp * r_factor, ct * r_factor, st * sp * r_factor);

        // Apply loop's tilt rotation
        vec3 tilted = rot_matrix * local_pos;

        // Global Y-axis rotation
        vec3 rotated = vec3(
            tilted.x * cos_rot - tilted.z * sin_rot,
            tilted.y,
            tilted.x * sin_rot + tilted.z * cos_rot
        );

        control_points[local_id] = rotated;
    }

    barrier();

    // --- Phase 2: All 240 threads generate one subdivision segment each ---
    uint cp_idx = local_id / 10;        // which control point pair (0-23)
    uint sub_idx = local_id % 10;       // which subdivision (0-9)

    // Get 4 control points for Catmull-Rom (wrapping for closed loop)
    vec3 p0 = control_points[(cp_idx + 23) % 24];  // (cp_idx - 1 + 24) % 24
    vec3 p1 = control_points[cp_idx];
    vec3 p2 = control_points[(cp_idx + 1) % 24];
    vec3 p3 = control_points[(cp_idx + 2) % 24];

    // t0 and t1 for this subdivision segment
    float t0 = float(sub_idx) / 10.0;
    float t1 = float(sub_idx + 1) / 10.0;

    vec3 pt0 = catmull_rom_3d(p0, p1, p2, p3, t0);
    vec3 pt1 = catmull_rom_3d(p0, p1, p2, p3, t1);

    // Perspective projection
    float persp0 = u_perspective_d / (u_perspective_d + pt0.z);
    float persp1 = u_perspective_d / (u_perspective_d + pt1.z);

    float sx0 = u_center.x + pt0.x * u_radius * persp0;
    float sy0 = u_center.y + pt0.y * u_radius * persp0;
    float sx1 = u_center.x + pt1.x * u_radius * persp1;
    float sy1 = u_center.y + pt1.y * u_radius * persp1;

    // Depth
    float persp_avg = (persp0 + persp1) * 0.5;
    float depth_norm = clamp((persp_avg - 0.5) / 1.0, 0.0, 1.0);

    // Thickness and brightness modulation
    float thickness_mod = 0.4 + depth_norm * 0.6;
    float brightness_mod = 0.3 + depth_norm * 0.7;

    float thickness = base_thickness * (1.0 + u_kick * 0.8) * thickness_mod;
    float brightness = base_brightness * (0.3 + band_energy * 0.4 + u_rms * 0.3) * (1.0 + u_snare * 2.0) * brightness_mod;

    // Dynamic loop dimming
    if (loop_idx >= u_active_loops) {
        float fade = max(0.0, 1.0 - float(loop_idx - u_active_loops) / 3.0);
        brightness *= fade;
    }

    // Write output segment
    uint seg_idx = loop_idx * 240 + local_id;
    uint out_base = seg_idx * 8;
    segment_data[out_base + 0] = sx0;
    segment_data[out_base + 1] = sy0;
    segment_data[out_base + 2] = sx1;
    segment_data[out_base + 3] = sy1;
    segment_data[out_base + 4] = thickness;
    segment_data[out_base + 5] = brightness;
    // Per-segment hue variation: shift by depth and position along loop
    float seg_progress = float(local_id) / 240.0;
    float hue_variation = depth_norm * 0.08 + seg_progress * 0.05;
    segment_data[out_base + 6] = hue_offset + hue_variation;
    segment_data[out_base + 7] = depth_norm;
}
